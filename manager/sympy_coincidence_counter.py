from typing import Union, List, Dict, Optional
from tqdm.auto import tqdm
from util.sympy_formula_evaluator import SymPyFormulaEvaluator




"""以下のようなjson形式のデータを取り扱うことを想定している

    json_data = [
        {
            "id": 1,
            "answers": [
                {"id": 1, "sympy_answer": "(r/(2+r)), 2, (1 - (Tmin/T0))", "output": "..."},
                {"id": 1, "sympy_answer": "(r/(2+r)), 2, 1 - Tmin/T0", "output": "..."},
                {"id": 1, "sympy_answer": "(r/(2+r)), 2, 1 - Tmin/T1", "output": "..."},
                {"id": 1, "sympy_answer": "r/(2+r)", "output": "..."},
            ]
        },
        {
            "id": 2,
            "answers": [
                {"id": 2, "sympy_answer": "x**2 + 2*x + 1", "output": "..."},
                {"id": 2, "sympy_answer": "(x+1)**2", "output": "..."},
                {"id": 2, "sympy_answer": "x**2 + 1 + 2*x", "output": "..."},
                {"id": 2, "sympy_answer": "NO ANSWER FOUND", "output": "..."},
                {"id": 2, "sympy_answer": " traversed clockwise.", "output": "..."},
                {"id": 2, "sympy_answer": "<Sympy-style final answer generated by the model>", "output": "..."},
                {"id": 2, "sympy_answer": "x**2 + 3*x + 1", "output": "..."},
                {"id": 2, "sympy_answer": "<Sympy-style final answer generated by the model>", "output": "..."},
                {"id": 2, "sympy_answer": "NO ANSWER FOUND", "output": "..."},
            ]
        }
    ]


"""


class CoincidenceCounter:
    def __init__(
            self,
            data: Union[Dict, List],
            group_key:str = "answers",
            sympy_key:str = "answer_sympy",
            leading_target_key:str = "reasoning",
    ):
        """
        {"id", "answers"}
        "answers":[{"id", "answer_sympy", "output"}]
          ↓
        {"id", "answers", "solution", "coincidences", "consistent_rate"}
        "answers":[{"id", "answer_sympy", "output", "num_of_coincidences"}]
        """
        self._data = data
        self._group_key = group_key
        self._sympy_key = sympy_key
        self._leading_target_key = leading_target_key
        self._evaluator: SymPyFormulaEvaluator = SymPyFormulaEvaluator(num_of_random_check=50)

    @staticmethod
    def split_sympy_answers(answer_str: str) -> List[str]:
        """カンマ区切りで複数の式を分割し、空白除去。以下のような文字列を想定
        "sympy_answer": "(r/(2+r)), 2, 1 - Tmin/T0"
        """
        return [s.strip() for s in answer_str.split(",")]

    def compare_multi_formula(self, ans_str1: str, ans_str2: str) -> float:
        """
        カンマ区切り対応の等価判定
        - 要素数が異なる場合 → 0点
        - 要素ごとに等価判定し、一致個数/要素数の点数を返す
        """
        list1 = self.split_sympy_answers(ans_str1)
        list2 = self.split_sympy_answers(ans_str2)

        if len(list1) != len(list2):
            return 0.0

        # print(list1)
        # print(list2)
        match_count = 0
        for f1, f2 in zip(list1, list2):
            if self._evaluator.evaluate(f1, f2):
                match_count += 1
        # print(match_count)
        # print('------------------')

        # 点数 = 一致個数 / 要素数
        return match_count / len(list1) if list1 else 0.0

    def process_answers_group(self, answers: List[Dict]) -> List[Dict]:
        """1つの id グループの answers に num_of_coincidences を追加"""
        # for i, ans in tqdm(enumerate(answers), total=len(answers)):
        for i, ans in enumerate(answers):
            target_formula = ans[self._sympy_key]
            score_sum = 0.0


            for other in answers:
                # print(target_formula)
                # print(other[self._sympy_key])
                # print('--------------------')

                score_sum += self.compare_multi_formula(
                    target_formula, other[self._sympy_key]
                )
            ans["num_of_coincidences"] = round(score_sum, 6)
        return answers

    def count_all(self) -> Union[Dict, List]:
        if isinstance(self._data, dict):
            self._data[self._group_key] = self.process_answers_group(self._data[self._group_key])
        elif isinstance(self._data, list):
            for group in self._data:
                group[self._group_key] = self.process_answers_group(group[self._group_key])
        else:
            raise ValueError("dataはdictまたはlistである必要があります")
        return self._data

    def get_leading_answer(self, answers) -> Optional[Dict]:
        if not answers:
            return None

        # 最大 num_of_coincidences を求める
        max_coincidence = max(a.get("num_of_coincidences", 0) for a in answers)

        # 全て 0 の場合
        if max_coincidence == 0:
            return None

        # num_of_coincidences が最大のものを抽出
        candidate_answers = [a for a in answers if a.get("num_of_coincidences", 0) == max_coincidence]

        # self._leading_target_keyのうち文字数が最も長いものを返す
        return max(candidate_answers, key=lambda x: len(x[self._leading_target_key])) if candidate_answers else None

    def update_base_json(self, target_id: Optional[int] = None):

        if target_id is None:
            items_to_process = self._data
        else:
            items_to_process = [item for item in self._data if item.get("id") == target_id]

        for item in items_to_process:
            answers = item.get(self._group_key, [])
            # num_of_coincidences を追加
            answers = self.process_answers_group(answers)
            num_of_rollout = len(answers)
            leading_answer_data = self.get_leading_answer(answers)
            if num_of_rollout != 0 and leading_answer_data:
                tmp = leading_answer_data.copy()
                tmp.pop("id", None)  # "id" がなければ無視
                item |= tmp  # leading_answer_dataを追加
                num_of_coincidences = leading_answer_data.get("num_of_coincidences", 0) if leading_answer_data else 0
                item["num_of_rollout"] = num_of_rollout
                item["consistent_rate"] = round(num_of_coincidences / num_of_rollout, 6)

        return self._data


if __name__ == "__main__":
    """
    python -m manager.sympy_coincidence_counter
    """

    from logging import DEBUG, INFO, WARNING, ERROR, basicConfig

    basicConfig(level=WARNING)
    # basicConfig(level=INFO)

    import json

    json_data = [
        {
            "id": 1,
            "answers": [
                {"id": 1, "sympy_answer": "0,0", "output": "..."},
                {"id": 1, "sympy_answer": "0, (mu_0 * pi * beta**3 * sigma_0**2 * R**8 * omega_0**2)/(27*c**3)",
                 "output": "..."},
            ]
        },
    ]

    # json_data = [
    #     {
    #         "id": 1,
    #         "answers": [
    #             {"id": 1, "sympy_answer": "(r/(2+r)), 2, (1 - (Tmin/T0))", "output": "..."},
    #             {"id": 1, "sympy_answer": "(r/(2+r)), 2, 1 - Tmin/T0", "output": "..."},
    #             {"id": 1, "sympy_answer": "(r/(2+r)), 2, 1 - Tmin/T1", "output": "..."},
    #             {"id": 1, "sympy_answer": "r/(2+r)", "output": "..."},
    #         ]
    #     },
    #     {
    #         "id": 2,
    #         "answers": [
    #             {"id": 2, "sympy_answer": "x**2 + 2*x + 1", "output": "..."},
    #             {"id": 2, "sympy_answer": "(x+1)**2", "output": "..."},
    #             {"id": 2, "sympy_answer": "x**2 + 1 + 2*x", "output": "..."},
    #             {"id": 2, "sympy_answer": "NO ANSWER FOUND", "output": "..."},
    #             {"id": 2, "sympy_answer": " traversed clockwise.", "output": "..."},
    #             {"id": 2, "sympy_answer": "<Sympy-style final answer generated by the model>", "output": "..."},
    #             {"id": 2, "sympy_answer": "x**2 + 3*x + 1", "output": "..."},
    #             {"id": 2, "sympy_answer": "<Sympy-style final answer generated by the model>", "output": "..."},
    #             {"id": 2, "sympy_answer": "NO ANSWER FOUND", "output": "..."},
    #         ]
    #     }
    # ]

    ## 複数要素対応
    counter = CoincidenceCounter(json_data, sympy_key="sympy_answer", leading_target_key="output")
    # updated_data = counter.count_all()
    # print(json.dumps(updated_data, ensure_ascii=False, indent=2))

    ## 代表回答
    # ==== 実行 ====
    # result = counter.update_base_json()
    result = counter.update_base_json(target_id=1)

    # ==== 出力 ====
    print(json.dumps(result, ensure_ascii=False, indent=2))
